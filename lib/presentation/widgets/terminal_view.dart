import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'package:kterm/kterm.dart';
import 'package:url_launcher/url_launcher.dart';

import 'error_dialog.dart';
import '../../data/models/ssh_connection.dart';
import '../../data/models/terminal_config.dart';
import '../../domain/services/terminal_service.dart';
import '../providers/terminal_provider.dart';
import '../providers/app_config_provider.dart';
import '../providers/connection_provider.dart';
import '../screens/app_settings_screen.dart';

/// 终端视图组件
class TerminalViewWidget extends StatefulWidget {
  final String sessionId;

  const TerminalViewWidget({super.key, required this.sessionId});

  @override
  State<TerminalViewWidget> createState() => _TerminalViewWidgetState();
}

class _TerminalViewWidgetState extends State<TerminalViewWidget> {
  @override
  Widget build(BuildContext context) {
    return Consumer2<TerminalProvider, AppConfigProvider>(
      builder: (context, terminalProvider, configProvider, child) {
        final session = terminalProvider.activeSession;

        if (session == null) {
          return const Center(child: Text('请选择一个连接'));
        }

        // 获取终端配置
        final config = configProvider.terminalConfig;

        // 解析颜色（从 #RRGGBB 格式转换为 Color）
        Color parseColor(String colorHex) {
          try {
            return Color(int.parse(colorHex.replaceFirst('#', '0xFF')));
          } catch (e) {
            return Colors.white;
          }
        }

        return LayoutBuilder(
          builder: (context, constraints) {
            return SizedBox(
              width: constraints.maxWidth,
              height: constraints.maxHeight,
              child: _TerminalViewWithSelection(
                terminal: session.terminal,
                controller: session.controller,
                config: config,
                parseColor: parseColor,
              ),
            );
          },
        );
      },
    );
  }
}

/// 带选择复制功能的 TerminalView 包装器
class _TerminalViewWithSelection extends StatefulWidget {
  final Terminal terminal;
  final TerminalController controller;
  final TerminalConfig config;
  final Color Function(String) parseColor;

  const _TerminalViewWithSelection({
    required this.terminal,
    required this.controller,
    required this.config,
    required this.parseColor,
  });

  @override
  State<_TerminalViewWithSelection> createState() => _TerminalViewWithSelectionState();
}

class _TerminalViewWithSelectionState extends State<_TerminalViewWithSelection> {
  String? _lastSelection;

  @override
  void initState() {
    super.initState();
    // 监听选择变化，自动复制到剪贴板
    widget.controller.addListener(_onSelectionChanged);
  }

  @override
  void dispose() {
    widget.controller.removeListener(_onSelectionChanged);
    super.dispose();
  }

  void _onSelectionChanged() {
    final selection = widget.controller.selection;
    if (selection != null) {
      final selectedText = widget.terminal.buffer.getText(selection);
      // 只有当选中文本发生变化时才复制到剪贴板
      if (selectedText != _lastSelection && selectedText.isNotEmpty) {
        _lastSelection = selectedText;
        Clipboard.setData(ClipboardData(text: selectedText));
      }
    } else {
      _lastSelection = null;
    }
  }

  @override
  Widget build(BuildContext context) {
    return TerminalView(
      widget.terminal,
      key: ValueKey(
        'terminal_${widget.config.fontSize}_${widget.config.fontFamily}',
      ),
      controller: widget.controller,
      autofocus: true,
      readOnly: false,
      // 确保启用文本输入（用于 IME/中文输入法）
      hardwareKeyboardOnly: false,
      // 使用通用文本输入类型
      keyboardType: TextInputType.text,
      textStyle: TerminalStyle(
        fontSize: widget.config.fontSize,
        fontFamily: widget.config.fontFamily.isEmpty ? 'Menlo' : widget.config.fontFamily,
        height: widget.config.lineHeight,
      ),
      theme: TerminalTheme(
        foreground: widget.parseColor(widget.config.foregroundColor),
        background: widget.parseColor(widget.config.backgroundColor),
        cursor: widget.parseColor(widget.config.cursorColor),
        selection: widget.parseColor(
          widget.config.foregroundColor,
        ).withValues(alpha: 0.3),
        black: widget.parseColor('#000000'),
        red: widget.parseColor('#CD3131'),
        green: widget.parseColor('#0DBC79'),
        yellow: widget.parseColor('#E5E510'),
        blue: widget.parseColor('#2472C8'),
        magenta: widget.parseColor('#BC3FBC'),
        cyan: widget.parseColor('#11A8CD'),
        white: widget.parseColor('#E5E5E5'),
        brightBlack: widget.parseColor('#666666'),
        brightRed: widget.parseColor('#F14C4C'),
        brightGreen: widget.parseColor('#23D18B'),
        brightYellow: widget.parseColor('#F5F543'),
        brightBlue: widget.parseColor('#3B8EEA'),
        brightMagenta: widget.parseColor('#D670D6'),
        brightCyan: widget.parseColor('#29B8DB'),
        brightWhite: widget.parseColor('#E5E5E5'),
        searchHitBackground: widget.parseColor('#FFFF00').withValues(alpha: 0.3),
        searchHitBackgroundCurrent: widget.parseColor('#FFFF00').withValues(alpha: 0.5),
        searchHitForeground: widget.parseColor('#000000'),
      ),
    );
  }
}


/// 终端标签页视图
class TerminalTabsView extends StatelessWidget {
  const TerminalTabsView({super.key});

  Future<void> _createLocalTerminal(BuildContext context) async {
    final terminalProvider = Provider.of<TerminalProvider>(
      context,
      listen: false,
    );
    try {
      await terminalProvider.createLocalTerminal();
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('创建终端失败: $e')),
        );
      }
    }
  }

  Future<void> _handleConnectionTap(
    BuildContext context,
    SshConnection connection,
  ) async {
    final terminalProvider = Provider.of<TerminalProvider>(
      context,
      listen: false,
    );

    final existingSession =
        terminalProvider.sessions.where((s) => s.id == connection.id).firstOrNull;

    if (existingSession != null) {
      terminalProvider.switchToSession(connection.id);
    } else {
      try {
        await terminalProvider.createSession(connection);
        final sshService = terminalProvider.getSshService(connection.id);

        if (sshService != null) {
          try {
            await sshService.connect(connection);
          } catch (e) {
            terminalProvider.closeSession(connection.id);
            if (context.mounted) {
              _showErrorDialog(context, connection, e.toString());
            }
          }
        }
      } catch (e) {
        if (context.mounted) {
          _showErrorDialog(context, connection, e.toString());
        }
      }
    }
  }

  /// 显示错误详情对话框
  void _showErrorDialog(
    BuildContext context,
    SshConnection connection,
    String errorMessage,
  ) {
    showDialog(
      context: context,
      builder: (context) => ErrorDetailDialog(
        connection: connection,
        errorMessage: errorMessage,
      ),
    );
  }

  List<PopupMenuItem<String>> _buildConnectionItems(
    BuildContext context,
    List<SshConnection> connections,
  ) {
    return connections.map((connection) {
      return PopupMenuItem(
        value: connection.id,
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.vpn_key,
              size: 18,
              color: Theme.of(context).colorScheme.primary,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Text(
                connection.name,
                overflow: TextOverflow.ellipsis,
              ),
            ),
          ],
        ),
      );
    }).toList();
  }

  @override
  Widget build(BuildContext context) {
    return Consumer2<TerminalProvider, ConnectionProvider>(
      builder: (context, terminalProvider, connProvider, child) {
        final sessions = terminalProvider.sessions;
        final activeSessionId = terminalProvider.activeSessionId;
        final connections = connProvider.connections;

        if (sessions.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.terminal,
                  size: 64,
                  color: Theme.of(
                    context,
                  ).colorScheme.onSurface.withValues(alpha: 0.3),
                ),
                const SizedBox(height: 16),
                Text(
                  '点击左侧连接以打开终端',
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    color: Theme.of(
                      context,
                    ).colorScheme.onSurface.withValues(alpha: 0.5),
                  ),
                ),
                const SizedBox(height: 16),
                TextButton.icon(
                  onPressed: () async {
                    try {
                      await terminalProvider.createLocalTerminal();
                    } catch (e, stackTrace) {
                      if (context.mounted) {
                        showErrorDialog(
                          context,
                          title: '创建终端失败',
                          error: e,
                          stackTrace: stackTrace,
                        );
                      }
                    }
                  },
                  icon: const Icon(Icons.add),
                  label: const Text('创建本地终端'),
                ),
              ],
            ),
          );
        }

        return Column(
          children: [
            // 标签页栏
            Container(
              height: 48,
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.surface,
                border: Border(
                  bottom: BorderSide(color: Theme.of(context).dividerColor),
                ),
              ),
              child: Row(
                children: [
                  // 设置按钮
                  Material(
                    color: Colors.transparent,
                    child: InkWell(
                      onTap: () {
                        Navigator.push(
                          context,
                          MaterialPageRoute(
                            builder: (context) => const AppSettingsScreen(),
                          ),
                        );
                      },
                      child: Container(
                        padding: const EdgeInsets.symmetric(
                          horizontal: 12,
                          vertical: 8,
                        ),
                        child: Icon(
                          Icons.settings,
                          size: 20,
                          color: Theme.of(context).colorScheme.onSurface,
                        ),
                      ),
                    ),
                  ),
                  // 标签列表
                  Expanded(
                    child: ListView.builder(
                      scrollDirection: Axis.horizontal,
                      itemCount: sessions.length,
                      itemBuilder: (context, index) {
                        final session = sessions[index];
                        final isActive = session.id == activeSessionId;

                        return _TerminalTab(
                          session: session,
                          isActive: isActive,
                          onTap: () => terminalProvider.switchToSession(session.id),
                          onClose: () => terminalProvider.closeSession(session.id),
                        );
                      },
                    ),
                  ),
                  // 下拉菜单按钮
                  PopupMenuButton<String>(
                    padding: EdgeInsets.zero,
                    child: Material(
                      color: Colors.transparent,
                      child: InkWell(
                        child: Container(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 12,
                            vertical: 8,
                          ),
                          child: Icon(
                            Icons.add,
                            size: 20,
                            color: Theme.of(context).colorScheme.primary,
                          ),
                        ),
                      ),
                    ),
                    itemBuilder: (context) {
                      final items = <PopupMenuEntry<String>>[
                        PopupMenuItem(
                          value: 'local_terminal',
                          child: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Icon(
                                Icons.computer,
                                size: 20,
                                color: Theme.of(context).colorScheme.primary,
                              ),
                              const SizedBox(width: 12),
                              const Text('本地终端'),
                            ],
                          ),
                        ),
                        const PopupMenuDivider(),
                      ];
                      if (connections.isEmpty) {
                        items.add(PopupMenuItem(
                          value: 'no_connections',
                          enabled: false,
                          child: Text(
                            '暂无保存的连接',
                            style: TextStyle(
                              color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.5),
                            ),
                          ),
                        ));
                      } else {
                        items.addAll(_buildConnectionItems(context, connections));
                      }
                      return items;
                    },
                    onSelected: (value) async {
                      if (value == 'no_connections') {
                        return;
                      }
                      if (value == 'local_terminal') {
                        await _createLocalTerminal(context);
                        return;
                      }
                      final connection = connections.firstWhere((c) => c.id == value);
                      await _handleConnectionTap(context, connection);
                    },
                  ),
                ],
              ),
            ),
            // 终端内容
            Expanded(
              child: activeSessionId != null
                  ? TerminalViewWidget(sessionId: activeSessionId)
                  : const SizedBox.shrink(),
            ),
          ],
        );
      },
    );
  }
}

/// 终端标签页
class _TerminalTab extends StatelessWidget {
  final TerminalSession session;
  final bool isActive;
  final VoidCallback onTap;
  final VoidCallback onClose;

  const _TerminalTab({
    required this.session,
    required this.isActive,
    required this.onTap,
    required this.onClose,
  });

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          decoration: BoxDecoration(
            color: isActive
                ? Theme.of(context).colorScheme.surface
                : Theme.of(context).colorScheme.surface.withValues(alpha: 0.5),
            border: Border(
              bottom: BorderSide(
                color: isActive
                    ? Theme.of(context).colorScheme.primary
                    : Colors.transparent,
                width: 2,
              ),
            ),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              ConstrainedBox(
                constraints: const BoxConstraints(maxWidth: 200),
                child: Text(
                  session.name,
                  style: TextStyle(
                    fontWeight: isActive ? FontWeight.bold : FontWeight.normal,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ),
              const SizedBox(width: 8),
              MouseRegion(
                cursor: SystemMouseCursors.click,
                child: GestureDetector(
                  onTap: () {
                    // 阻止事件冒泡，避免触发父级的 onTap
                    onClose();
                  },
                  child: Container(
                    padding: const EdgeInsets.all(4),
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(12),
                      color: Colors.transparent,
                    ),
                    child: Icon(
                      Icons.close,
                      size: 16,
                      color: Theme.of(
                        context,
                      ).colorScheme.onSurface.withValues(alpha: 0.6),
                    ),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

/// 错误详情对话框
class ErrorDetailDialog extends StatefulWidget {
  final SshConnection connection;
  final String errorMessage;

  const ErrorDetailDialog({
    super.key,
    required this.connection,
    required this.errorMessage,
  });

  @override
  State<ErrorDetailDialog> createState() => _ErrorDetailDialogState();
}

class _ErrorDetailDialogState extends State<ErrorDetailDialog> {
  bool _copied = false;

  Future<void> _copyAndOpenIssues() async {
    final connection = widget.connection;
    final error = widget.errorMessage;

    // 构建错误报告内容
    final report = '''## 错误报告

**连接名称**: ${connection.name}
**主机**: ${connection.host}:${connection.port}
**用户名**: ${connection.username}
**认证方式**: ${connection.authType.name}
${connection.jumpHost != null ? '**跳板机**: ${connection.jumpHost!.host}:${connection.jumpHost!.port}' : ''}
${connection.socks5Proxy != null ? '**SOCKS5 代理**: ${connection.socks5Proxy!.host}:${connection.socks5Proxy!.port}' : ''}

**错误信息**:
```
$error
```

**复现步骤**:
1. 选择连接 "${connection.name}"
2. 点击连接
3. 出现上述错误

**环境信息**:
- 操作系统: ${Platform.operatingSystem}
- 应用版本: lbpSSH''';

    // 复制到剪贴板
    await Clipboard.setData(ClipboardData(text: report));

    setState(() {
      _copied = true;
    });

    // 打开 GitHub Issues 页面
    final Uri issuesUrl = Uri.parse(
      'https://github.com/lbpCode/lbpSSH/issues/new',
    );
    if (await canLaunchUrl(issuesUrl)) {
      await launchUrl(issuesUrl, mode: LaunchMode.externalApplication);
    }

    // 3秒后重置复制状态
    Future.delayed(const Duration(seconds: 3), () {
      if (mounted) {
        setState(() {
          _copied = false;
        });
      }
    });
  }

  Future<void> _copyErrorOnly() async {
    await Clipboard.setData(
      ClipboardData(text: widget.errorMessage),
    );
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('错误信息已复制到剪贴板')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return AlertDialog(
      title: Row(
        children: [
          Icon(Icons.error_outline, color: theme.colorScheme.error),
          const SizedBox(width: 12),
          const Text('连接失败'),
        ],
      ),
      content: SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisSize: MainAxisSize.min,
          children: [
            // 连接信息
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: theme.colorScheme.surfaceVariant,
                borderRadius: BorderRadius.circular(8),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  _buildInfoRow('连接名称', widget.connection.name),
                  _buildInfoRow('主机地址',
                      '${widget.connection.host}:${widget.connection.port}'),
                  _buildInfoRow('用户名', widget.connection.username),
                  _buildInfoRow('认证方式',
                      _getAuthTypeName(widget.connection.authType)),
                  if (widget.connection.jumpHost != null)
                    _buildInfoRow('跳板机',
                        '${widget.connection.jumpHost!.host}:${widget.connection.jumpHost!.port}'),
                  if (widget.connection.socks5Proxy != null)
                    _buildInfoRow('SOCKS5 代理',
                        '${widget.connection.socks5Proxy!.host}:${widget.connection.socks5Proxy!.port}'),
                ],
              ),
            ),
            const SizedBox(height: 16),
            // 错误信息
            Text(
              '错误信息',
              style: theme.textTheme.titleSmall?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 8),
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: theme.colorScheme.errorContainer.withValues(alpha: 0.3),
                border: Border.all(color: theme.colorScheme.error.withValues(alpha: 0.5)),
                borderRadius: BorderRadius.circular(8),
              ),
              child: SelectableText(
                widget.errorMessage,
                style: TextStyle(
                  color: theme.colorScheme.error,
                  fontFamily: 'monospace',
                  fontSize: 13,
                ),
              ),
            ),
            const SizedBox(height: 16),
            // 解决方案提示
            _buildSolutionHint(widget.errorMessage, theme),
          ],
        ),
      ),
      actions: [
        TextButton.icon(
          onPressed: _copyErrorOnly,
          icon: const Icon(Icons.content_copy),
          label: const Text('复制错误'),
        ),
        ElevatedButton.icon(
          onPressed: _copyAndOpenIssues,
          icon: _copied
              ? const Icon(Icons.check)
              : const Icon(Icons.bug_report_outlined),
          style: ElevatedButton.styleFrom(
            backgroundColor: theme.colorScheme.primary,
            foregroundColor: theme.colorScheme.onPrimary,
          ),
          label: Text(_copied ? '已复制，前往 Issues' : '反馈问题'),
        ),
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('关闭'),
        ),
      ],
    );
  }

  Widget _buildInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 80,
            child: Text(
              label,
              style: TextStyle(
                color: Colors.grey.shade600,
                fontSize: 12,
              ),
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: const TextStyle(
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSolutionHint(String errorMessage, ThemeData theme) {
    final hint = _getSolutionHint(errorMessage);
    final isPtyError = errorMessage.toLowerCase().contains('pty') ||
        errorMessage.toLowerCase().contains('tty');

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(
              isPtyError ? Icons.computer : Icons.lightbulb_outline,
              size: 18,
              color: isPtyError
                  ? theme.colorScheme.error
                  : theme.colorScheme.primary,
            ),
            const SizedBox(width: 8),
            Text(
              isPtyError ? '可能原因与解决方法' : '排查建议',
              style: theme.textTheme.titleSmall?.copyWith(
                fontWeight: FontWeight.bold,
                color: isPtyError
                    ? theme.colorScheme.error
                    : theme.colorScheme.primary,
              ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        Container(
          width: double.infinity,
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            color: (isPtyError
                    ? theme.colorScheme.errorContainer.withValues(alpha: 0.1)
                    : theme.colorScheme.primaryContainer.withValues(alpha: 0.3))
                .withValues(alpha: 0.5),
            border: Border.all(
              color: (isPtyError
                      ? theme.colorScheme.error.withValues(alpha: 0.3)
                      : theme.colorScheme.primary.withValues(alpha: 0.3)),
            ),
            borderRadius: BorderRadius.circular(8),
          ),
          child: SelectableText(
            hint,
            style: TextStyle(
              color: theme.colorScheme.onSurface,
              fontSize: 13,
              height: 1.5,
            ),
          ),
        ),
      ],
    );
  }

  String _getAuthTypeName(AuthType authType) {
    switch (authType) {
      case AuthType.password:
        return '密码认证';
      case AuthType.key:
        return '密钥认证';
      case AuthType.keyWithPassword:
        return '密钥+密码认证';
      case AuthType.sshConfig:
        return 'SSH Config';
    }
  }

  /// 获取特定错误的解决方案建议
  String _getSolutionHint(String errorMessage) {
    final lowerError = errorMessage.toLowerCase();

    if (lowerError.contains('failed to start pty') ||
        lowerError.contains('pty') ||
        lowerError.contains('tty')) {
      return '''**可能原因**:
• 服务器配置了 `PermitTTY no`
• 用户没有分配伪终端的权限
• 该账户可能仅允许 SFTP 访问（无 Shell 权限）

**解决方法**:
• 联系服务器管理员检查 SSH 配置
• 确认账户是否有 Shell 访问权限
• 检查 `/etc/ssh/sshd_config` 中的 `PermitTTY` 设置''';
    }

    if (lowerError.contains('authentication failed') ||
        lowerError.contains('authenticate') ||
        lowerError.contains('permission denied')) {
      return '''**可能原因**:
• 密码/密钥验证失败
• 密钥权限不正确（应设置为 600）
• 服务器未授权该用户登录

**解决方法**:
• 确认密码或私钥是否正确
• 检查私钥文件权限: `chmod 600 ~/.ssh/id_rsa`
• 确认公钥已添加到服务器的 `~/.ssh/authorized_keys`''';
    }

    if (lowerError.contains('connection refused') ||
        lowerError.contains('network is unreachable') ||
        lowerError.contains('no route to host')) {
      return '''**可能原因**:
• SSH 服务未运行或端口错误
• 防火墙阻止了连接
• 网络不可达

**解决方法**:
• 确认主机地址和端口是否正确
• 检查服务器防火墙规则 (端口 22)
• 确认 SSH 服务正在运行''';
    }

    if (lowerError.contains('host key verification') ||
        lowerError.contains('known_hosts') ||
        lowerError.contains('key')) {
      return '''**可能原因**:
• 主机密钥验证失败
• 主机地址已更换或被攻击

**解决方法**:
• 检查是否连接到了正确的服务器
• 如确认安全，可删除 `~/.ssh/known_hosts` 中对应条目''';
    }

    return '''**排查建议**:
• 确认主机地址、端口、用户名正确
• 检查网络连接和防火墙设置
• 确认账户有 SSH 访问权限''';
  }
}
